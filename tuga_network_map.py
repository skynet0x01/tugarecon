#!/usr/bin/python3
# TugaRecon, tribute to Portuguese explorers reminding glorious past of this country
# Bug Bounty Recon, search for subdomains and save into a file
# Coded By skynet0x01 2020-2025

# This file is part of TugaRecon, developed by skynet0x01 in 2020-2025.
#
# Copyright (C) 2025 skynet0x01
#
# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program. If not, see <https://www.gnu.org/licenses/>.
#
# Patent Restriction Notice:
# No patents may be claimed or enforced on this software or any derivative.
# Any patent claims will result in automatic termination of license rights under the GNU GPLv3.
# ----------------------------------------------------------------------------------------------------------


# imports
import os
import sys
import asyncio
import ipaddress
import pydot
import json
import csv
import socket
import ssl
import re

from datetime import datetime
from ipwhois import IPWhois
from utils.tuga_colors import R, W, Y
# ----------------------------------------------------------------------------------------------------------


# Optional imports for certificate parsing and interactive export
try:
    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
    CRYPTO_AVAILABLE = True
except Exception:
    CRYPTO_AVAILABLE = False

try:
    from pyvis.network import Network
    import networkx as nx
    PYVIS_AVAILABLE = True
except Exception:
    PYVIS_AVAILABLE = False
# ----------------------------------------------------------------------------------------------------------
# Footer text
FOOTER_TEXT = "Map generated by: https://github.com/skynet0x01/tugarecon"

# ----------------------------------------------------------------------------------------------------------
# Simple RDAP cache
rdap_cache = {}

# ----------------------------------------------------------------------------------------------------------
# Read subdomains from file
def read_subdomains(file_path):
    with open(file_path, 'r') as f:
        return [line.strip() for line in f if line.strip() and not line.startswith('#')]
# ----------------------------------------------------------------------------------------------------------


# Read bruteforce results
def read_bruteforce(file_path):
    with open(file_path, 'r') as f:
        return [line.strip() for line in f if line.strip() and not line.startswith('#')]
# ----------------------------------------------------------------------------------------------------------


# Merge sources
def merge_sources(sub_file, bruteforce_file=None):
    subs = set(read_subdomains(sub_file)) if os.path.isfile(sub_file) else set()
    brut = set()
    if bruteforce_file and os.path.isfile(bruteforce_file):
        brut = set(read_bruteforce(bruteforce_file))

    all_hosts = subs.union(brut)
    host_sources = {}
    for h in all_hosts:
        if h in subs and h in brut:
            host_sources[h] = 'both'
        elif h in subs:
            host_sources[h] = 'subdomains'
        else:
            host_sources[h] = 'bruteforce'
    return host_sources, list(all_hosts)

# ----------------------------------------------------------------------------------------------------------


# Async DNS resolution
async def resolve_ip(domain):
    loop = asyncio.get_event_loop()
    try:
        infos = await loop.getaddrinfo(domain, None)
        return infos[0][4][0] if infos else None
    except Exception:
        return None
# ----------------------------------------------------------------------------------------------------------


async def resolve_all_ips(domains, concurrency=200):
    ip_map = {}
    sem = asyncio.Semaphore(concurrency)

    async def safe_resolve(domain):
        async with sem:
            ip = await resolve_ip(domain)
            if ip:
                ip_map[domain] = ip

    tasks = [safe_resolve(d) for d in domains]
    await asyncio.gather(*tasks, return_exceptions=True)
    return ip_map
# ----------------------------------------------------------------------------------------------------------


# Lookup ASN and network info
async def prefetch_network_info(ip_set, concurrency=20):
    sem = asyncio.Semaphore(concurrency)

    async def do_lookup(ip):
        async with sem:
            if ip in rdap_cache:
                return
            try:
                ip_obj = ipaddress.ip_address(ip)
                if ip_obj.is_private:
                    rdap_cache[ip] = {'asn':'Private Network','asn_description':'Private Network','country':'N/A','cidr':'N/A','org':'Local/Internal'}
                    return
            except Exception:
                rdap_cache[ip] = {'asn':'Invalid','asn_description':'Invalid IP','country':'N/A','cidr':'N/A','org':'N/A'}
                return
            try:
                obj = IPWhois(ip)
                res = await asyncio.to_thread(obj.lookup_rdap)
                asn = res.get('asn') or 'Unknown'
                asn_desc = res.get('asn_description') or asn or 'Unknown ASN'
                country = res.get('asn_country_code') or '??'
                cidr = res.get('network',{}).get('cidr') or 'Unknown'
                org = res.get('network',{}).get('name') or 'Unknown Org'
                rdap_cache[ip] = {'asn':asn,'asn_description':asn_desc,'country':country,'cidr':cidr,'org':org}
            except Exception:
                rdap_cache[ip] = {'asn':'Unknown','asn_description':'RDAP error','country':'??','cidr':'Unknown','org':'Unknown Org'}

    tasks = [do_lookup(ip) for ip in ip_set]
    await asyncio.gather(*tasks, return_exceptions=True)

def lookup_network_info(ip):
    return rdap_cache.get(ip, {'asn':'Unknown','asn_description':'Unknown ASN','country':'??','cidr':'Unknown','org':'Unknown Org'})
# ----------------------------------------------------------------------------------------------------------


# Node classification
def classify_node(sub):
    sub = sub.lower()
    if any(x in sub for x in ['mail','smtp','imap','mx']): return 'üìß','#ffd699'
    elif any(x in sub for x in ['web','www','http','site']): return 'üåê','#b3d9ff'
    elif any(x in sub for x in ['printer','print']): return 'üñ®Ô∏è','#ffcccc'
    elif any(x in sub for x in ['router','gateway']): return 'üì°','#ccffcc'
    elif any(x in sub for x in ['nas','file','storage']): return 'üíæ','#e0e0e0'
    elif any(x in sub for x in ['cam','camera']): return 'üì∑','#ffe0b3'
    elif any(x in sub for x in ['dev','test','lab']): return 'üß™','#e6ccff'
    else: return 'üíª','#f2f2f2'
# ----------------------------------------------------------------------------------------------------------


def shorten_label(text,max_len=30):
    if len(text)<=max_len: return text
    parts = text.split('.')
    return '\n'.join(['.'.join(parts[i:i+2]) for i in range(0,len(parts),2)])

# ----------------------------------------------------------------------------------------------------------
# Fetch certificates
def fetch_cert_sync(host, port=443, timeout=5):
    try:
        ctx = ssl.create_default_context()
        if hasattr(ssl,"TLSVersion"):
            ctx.minimum_version = ssl.TLSVersion.TLSv1_2
        else:
            ctx.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1
        with socket.create_connection((host,port),timeout=timeout) as sock:
            with ctx.wrap_socket(sock,server_hostname=host) as ss:
                return ss.getpeercert(binary_form=True)
    except Exception:
        return None
# ----------------------------------------------------------------------------------------------------------


async def fetch_certs_for_hosts(hosts_list, concurrency=40, timeout=5):
    cert_map_local = {}
    sem = asyncio.Semaphore(concurrency)
    async def worker(host):
        async with sem:
            der = await asyncio.to_thread(fetch_cert_sync, host, 443, timeout)
            sans = []
            if der and CRYPTO_AVAILABLE:
                try:
                    cert = x509.load_der_x509_certificate(der, default_backend())
                    ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName)
                    sans.extend(ext.value.get_values_for_type(x509.DNSName))
                    cn = cert.subject.get_attributes_for_oid(x509.oid.NameOID.COMMON_NAME)[0].value
                    if cn and cn not in sans: sans.append(cn)
                except Exception:
                    pass
            cert_map_local[host] = sans
    tasks=[worker(h) for h in hosts_list]
    await asyncio.gather(*tasks, return_exceptions=True)
    return cert_map_local
# ----------------------------------------------------------------------------------------------------------


# Build graph
def build_graph_with_clusters(subs_ips, host_sources=None, cert_map=None):
    if cert_map is None: cert_map = {}
    graph = pydot.Dot(graph_type='digraph', rankdir='LR')
    clusters = {}
    network_summary = {}
    for host, ip in subs_ips.items():
        info = lookup_network_info(ip)
        asn = info.get('asn') or 'Unknown'
        asn_id = re.sub(r'[^0-9A-Za-z_]','_',asn)
        if asn_id not in clusters:
            cluster = pydot.Cluster(asn_id,label=f"{asn} ({info.get('country','??')})", style='filled', fillcolor='#f0f0f0')
            clusters[asn_id] = cluster
            network_summary[asn_id] = {'asn_display':asn,'country':info.get('country','??'),'cidrs':set(),'orgs':set(),'hosts':[]}
            graph.add_subgraph(cluster)
        cluster = clusters[asn_id]
        emoji,color = classify_node(host)
        node_label = f"{emoji} {shorten_label(host)}\n[{host_sources.get(host,'unknown')}]"
        node = pydot.Node(node_label, style='filled', fillcolor=color, shape='box')
        cluster.add_node(node)
        ip_node = pydot.Node(ip,label=ip, style='filled', fillcolor='lightblue', shape='ellipse')
        cluster.add_node(ip_node)
        graph.add_edge(pydot.Edge(node, ip_node))
        # SAN edges
        for san in cert_map.get(host,[]):
            if san != host:
                san_node = pydot.Node(f"üîñ {shorten_label(san)}\n[cert]", style='rounded')
                cluster.add_node(san_node)
                graph.add_edge(pydot.Edge(node,san_node,style='dashed'))
        # summary
        network_summary[asn_id]['cidrs'].add(info.get('cidr','Unknown'))
        network_summary[asn_id]['orgs'].add(info.get('org','Unknown Org'))
        network_summary[asn_id]['hosts'].append({'host':host,'ip':ip,'source':host_sources.get(host,'unknown')})
    # Footer node
    footer_node = pydot.Node('footer',label=FOOTER_TEXT, shape='plaintext', fontsize='14')
    graph.add_node(footer_node)
    footer_cluster = pydot.Cluster('footer_cluster', style='invis')
    footer_cluster.add_node(footer_node)
    graph.add_subgraph(footer_cluster)
    return graph, network_summary
# ----------------------------------------------------------------------------------------------------------


# Export graph and summaries
def export_graph(graph, latest_path):
    os.makedirs(latest_path, exist_ok=True)
    pdf_path = os.path.join(latest_path,'subdomains_clustered.pdf')
    svg_path = os.path.join(latest_path,'subdomains_clustered.svg')
    dot_path = os.path.join(latest_path,'subdomains_clustered.dot')
    try:
        graph.write_pdf(pdf_path)
        graph.write_svg(svg_path)
        graph.write_raw(dot_path)
        print(f"[+] Graph exported: PDF/SVG/DOT")
    except Exception as e:
        print(R + f"[!] Failed to export graph: {e}" + W)
# ----------------------------------------------------------------------------------------------------------


def export_network_summary(network_summary, latest_path):
    os.makedirs(latest_path, exist_ok=True)
    txt_file = os.path.join(latest_path,'network_info.txt')
    json_file = os.path.join(latest_path,'network_info.json')
    csv_file = os.path.join(latest_path,'network_info.csv')

    # TXT
    with open(txt_file,'w') as f:
        for asn,data in network_summary.items():
            f.write(f"ASN: {data['asn_display']}\nCountry: {data['country']}\nOrgs: {', '.join(data['orgs'])}\nCIDRs: {', '.join(data['cidrs'])}\n")
            for h in data['hosts']:
                f.write(f"  - {h['host']} -> {h['ip']} ({h['source']})\n")
            f.write("\n")
        f.write(FOOTER_TEXT+'\n')

    # JSON
    json_safe = {}
    for asn,data in network_summary.items():
        json_safe[asn] = {'asn_display':data['asn_display'],'country':data['country'],'orgs':list(data['orgs']),'cidrs':list(data['cidrs']),'hosts':data['hosts']}
    with open(json_file,'w') as f:
        json.dump({'network_summary':json_safe,'_footer':FOOTER_TEXT},f,indent=2)

    # CSV
    with open(csv_file,'w',newline='') as f:
        writer = csv.writer(f)
        writer.writerow(['asn','country','orgs','cidrs','host','ip','source'])
        for asn,data in network_summary.items():
            for h in data['hosts']:
                writer.writerow([data['asn_display'],data['country'],';'.join(data['orgs']),';'.join(data['cidrs']),h['host'],h['ip'],h['source']])
        writer.writerow([f"# {FOOTER_TEXT}"])

    print(f"[+] Network info exported: TXT/JSON/CSV with footer")
# ----------------------------------------------------------------------------------------------------------

# HTML interactive PyVis
def export_pyvis(network_summary, latest_path):
    if not PYVIS_AVAILABLE:
        print(Y+"PyVis/networkx not installed, skipping HTML export"+W)
        return
    try:
        G = nx.Graph()
        for asn,data in network_summary.items():
            for h in data['hosts']:
                G.add_node(h['host'], title=f"Host: {h['host']}<br>IP: {h['ip']}")
                G.add_node(h['ip'], title=f"IP: {h['ip']}<br>ASN: {data.get('asn_display','Unknown')}<br>Country: {data.get('country','??')}")
                G.add_edge(h['host'],h['ip'])
        net = Network(height='1000px', width='100%', notebook=False)
        net.from_nx(G)
        outpath = os.path.join(latest_path,'subdomains_map.html')
        net.write_html(outpath)
        # inject footer
        with open(outpath,'r',encoding='utf-8') as f:
            html=f.read()
        html=html.replace('</body>',f'<div style="position:fixed;bottom:8px;left:8px;font-size:12px;opacity:0.8;z-index:9999;">{FOOTER_TEXT}</div></body>')
        with open(outpath,'w',encoding='utf-8') as f:
            f.write(html)
        print(f"[+] Interactive map exported: {outpath}")
    except Exception as e:
        print(R+"Failed PyVis export: "+str(e)+W)

# ----------------------------------------------------------------------------------------------------------
# Main async workflow
async def main_async(sub_file, brut_file, latest_path):
    host_sources, hosts = merge_sources(sub_file, brut_file)
    print(f"[+] Resolving {len(hosts)} hosts...")
    ip_map = await resolve_all_ips(hosts)
    if not ip_map:
        print("[-] No hosts resolved")
        return
    await prefetch_network_info(set(ip_map.values()))
    cert_map = await fetch_certs_for_hosts(hosts)
    graph, network_summary = build_graph_with_clusters(ip_map, host_sources, cert_map)
    export_graph(graph, latest_path)
    export_network_summary(network_summary, latest_path)
    export_pyvis(network_summary, latest_path)
    # Save certs
    cert_file = os.path.join(latest_path,'cert_sans.json')
    with open(cert_file,'w') as f:
        json.dump(cert_map,f,indent=2)
    print(f"[+] Certificate SAN map saved: {cert_file}")

# ----------------------------------------------------------------------------------------------------------
# Latest folder
def get_latest_date_folder(base_path):
    try:
        folders = [f for f in os.listdir(base_path) if os.path.isdir(os.path.join(base_path,f))]
    except Exception:
        print(R+"Base folder not found: "+base_path+W); sys.exit(1)
    date_folders=[]
    for f in folders:
        try: date_folders.append((datetime.strptime(f,'%Y-%m-%d'),f))
        except Exception: pass
    if not date_folders: print(R+"No date folders found"+W); sys.exit(1)
    date_folders.sort()
    return os.path.join(base_path,date_folders[-1][1])

# ----------------------------------------------------------------------------------------------------------
# Main map function
def tuga_map(target):
    base_path = os.path.join('results',target)
    latest_path = get_latest_date_folder(base_path)
    print(Y+f"Using folder: {latest_path}"+W)

    sub_file = os.path.join(latest_path,'subdomains.txt')
    brut_file = os.path.join(latest_path,'tuga_bruteforce.txt')

    if not os.path.isfile(sub_file) and not os.path.isfile(brut_file):
        print(R+"No subdomains/bruteforce files found"+W); sys.exit(1)
    asyncio.run(main_async(sub_file,brut_file,latest_path))
