# --------------------------------------------------------------------------------------------------
# TugaRecon
# Author: Skynet0x01 2020-2026
# GitHub: https://github.com/skynet0x01/tugarecon
# License: GNU GPLv3
# Patent Restriction Notice:
# No patents may be claimed or enforced on this software or any derivative.
# Any patent claims will result in automatic termination of license rights under the GNU GPLv3.
# --------------------------------------------------------------------------------------------------
import os
import sys
import asyncio
import ipaddress
import pydot
import json
import csv
import socket
import ssl
import re

from datetime import datetime
from ipwhois import IPWhois
from utils.tuga_colors import R, W, Y
# ----------------------------------------------------------------------------------------------------------


# Optional imports for certificate parsing and interactive export
try:
    from cryptography import x509
    from cryptography.hazmat.backends import default_backend
    CRYPTO_AVAILABLE = True
except Exception:
    CRYPTO_AVAILABLE = False

try:
    from pyvis.network import Network
    import networkx as nx
    PYVIS_AVAILABLE = True
except Exception:
    PYVIS_AVAILABLE = False
# ----------------------------------------------------------------------------------------------------------
# Footer text
FOOTER_TEXT = "Map generated by: https://github.com/skynet0x01/tugarecon"

# ----------------------------------------------------------------------------------------------------------
# Simple RDAP cache
rdap_cache = {}

# ----------------------------------------------------------------------------------------------------------
# Read subdomains from file
def read_subdomains(file_path):
    with open(file_path, 'r') as f:
        return [line.strip() for line in f if line.strip() and not line.startswith('#')]
# ----------------------------------------------------------------------------------------------------------


# Read bruteforce results
def read_bruteforce(file_path):
    with open(file_path, 'r') as f:
        return [line.strip() for line in f if line.strip() and not line.startswith('#')]
# ----------------------------------------------------------------------------------------------------------


# Merge sources
def merge_sources(sub_file, bruteforce_file=None):
    subs = set(read_subdomains(sub_file)) if os.path.isfile(sub_file) else set()
    brut = set()
    if bruteforce_file and os.path.isfile(bruteforce_file):
        brut = set(read_bruteforce(bruteforce_file))

    all_hosts = subs.union(brut)
    host_sources = {}
    for h in all_hosts:
        if h in subs and h in brut:
            host_sources[h] = 'both'
        elif h in subs:
            host_sources[h] = 'subdomains'
        else:
            host_sources[h] = 'bruteforce'
    return host_sources, list(all_hosts)

# ----------------------------------------------------------------------------------------------------------


# Async DNS resolution
async def resolve_ip(domain):
    loop = asyncio.get_event_loop()
    try:
        infos = await loop.getaddrinfo(domain, None)
        return infos[0][4][0] if infos else None
    except Exception:
        return None
# ----------------------------------------------------------------------------------------------------------


async def resolve_all_ips(domains, concurrency=200):
    ip_map = {}
    sem = asyncio.Semaphore(concurrency)

    async def safe_resolve(domain):
        async with sem:
            ip = await resolve_ip(domain)
            if ip:
                ip_map[domain] = ip

    tasks = [safe_resolve(d) for d in domains]
    await asyncio.gather(*tasks, return_exceptions=True)
    return ip_map
# ----------------------------------------------------------------------------------------------------------


# Lookup ASN and network info
async def prefetch_network_info(ip_set, concurrency=20):
    sem = asyncio.Semaphore(concurrency)

    async def do_lookup(ip):
        async with sem:
            if ip in rdap_cache:
                return
            try:
                ip_obj = ipaddress.ip_address(ip)
                if ip_obj.is_private:
                    rdap_cache[ip] = {'asn':'Private Network','asn_description':'Private Network','country':'N/A','cidr':'N/A','org':'Local/Internal'}
                    return
            except Exception:
                rdap_cache[ip] = {'asn':'Invalid','asn_description':'Invalid IP','country':'N/A','cidr':'N/A','org':'N/A'}
                return
            try:
                obj = IPWhois(ip)
                res = await asyncio.to_thread(obj.lookup_rdap)
                asn = res.get('asn') or 'Unknown'
                asn_desc = res.get('asn_description') or asn or 'Unknown ASN'
                country = res.get('asn_country_code') or '??'
                cidr = res.get('network',{}).get('cidr') or 'Unknown'
                org = res.get('network',{}).get('name') or 'Unknown Org'
                rdap_cache[ip] = {'asn':asn,'asn_description':asn_desc,'country':country,'cidr':cidr,'org':org}
            except Exception:
                rdap_cache[ip] = {'asn':'Unknown','asn_description':'RDAP error','country':'??','cidr':'Unknown','org':'Unknown Org'}

    tasks = [do_lookup(ip) for ip in ip_set]
    await asyncio.gather(*tasks, return_exceptions=True)

def lookup_network_info(ip):
    return rdap_cache.get(ip, {'asn':'Unknown','asn_description':'Unknown ASN','country':'??','cidr':'Unknown','org':'Unknown Org'})
# ----------------------------------------------------------------------------------------------------------


# Node classification
def classify_node(sub):
    sub = sub.lower()
    if any(x in sub for x in ['mail','smtp','imap','mx']): return 'üìß','#ffd699'
    elif any(x in sub for x in ['web','www','http','site']): return 'üåê','#b3d9ff'
    elif any(x in sub for x in ['printer','print']): return 'üñ®Ô∏è','#ffcccc'
    elif any(x in sub for x in ['router','gateway']): return 'üì°','#ccffcc'
    elif any(x in sub for x in ['nas','file','storage']): return 'üíæ','#e0e0e0'
    elif any(x in sub for x in ['cam','camera']): return 'üì∑','#ffe0b3'
    elif any(x in sub for x in ['dev','test','lab']): return 'üß™','#e6ccff'
    else: return 'üíª','#f2f2f2'
# ----------------------------------------------------------------------------------------------------------


def shorten_label(text,max_len=30):
    if len(text)<=max_len: return text
    parts = text.split('.')
    return '\n'.join(['.'.join(parts[i:i+2]) for i in range(0,len(parts),2)])

# ----------------------------------------------------------------------------------------------------------
# Fetch certificates
def fetch_cert_sync(host, port=443, timeout=5):
    try:
        ctx = ssl.create_default_context()
        if hasattr(ssl,"TLSVersion"):
            ctx.minimum_version = ssl.TLSVersion.TLSv1_2
        else:
            ctx.options |= ssl.OP_NO_TLSv1 | ssl.OP_NO_TLSv1_1
        with socket.create_connection((host,port),timeout=timeout) as sock:
            with ctx.wrap_socket(sock,server_hostname=host) as ss:
                return ss.getpeercert(binary_form=True)
    except Exception:
        return None
# ----------------------------------------------------------------------------------------------------------


async def fetch_certs_for_hosts(hosts_list, concurrency=40, timeout=5):
    cert_map_local = {}
    sem = asyncio.Semaphore(concurrency)
    async def worker(host):
        async with sem:
            der = await asyncio.to_thread(fetch_cert_sync, host, 443, timeout)
            sans = []
            if der and CRYPTO_AVAILABLE:
                try:
                    cert = x509.load_der_x509_certificate(der, default_backend())
                    ext = cert.extensions.get_extension_for_class(x509.SubjectAlternativeName)
                    sans.extend(ext.value.get_values_for_type(x509.DNSName))
                    cn = cert.subject.get_attributes_for_oid(x509.oid.NameOID.COMMON_NAME)[0].value
                    if cn and cn not in sans: sans.append(cn)
                except Exception:
                    pass
            cert_map_local[host] = sans
    tasks=[worker(h) for h in hosts_list]
    await asyncio.gather(*tasks, return_exceptions=True)
    return cert_map_local
# ----------------------------------------------------------------------------------------------------------


# Build graph
def build_graph_with_clusters(subs_ips, host_sources=None, cert_map=None):
    if cert_map is None: cert_map = {}
    graph = pydot.Dot(graph_type='digraph', rankdir='LR')
    clusters = {}
    network_summary = {}
    for host, ip in subs_ips.items():
        info = lookup_network_info(ip)
        asn = info.get('asn') or 'Unknown'
        asn_id = re.sub(r'[^0-9A-Za-z_]','_',asn)
        if asn_id not in clusters:
            cluster = pydot.Cluster(asn_id,label=f"{asn} ({info.get('country','??')})", style='filled', fillcolor='#f0f0f0')
            clusters[asn_id] = cluster
            network_summary[asn_id] = {'asn_display':asn,'country':info.get('country','??'),'cidrs':set(),'orgs':set(),'hosts':[]}
            graph.add_subgraph(cluster)
        cluster = clusters[asn_id]
        emoji,color = classify_node(host)
        node_label = f"{emoji} {shorten_label(host)}\n[{host_sources.get(host,'unknown')}]"
        node = pydot.Node(node_label, style='filled', fillcolor=color, shape='box')
        cluster.add_node(node)
        ip_node = pydot.Node(ip,label=ip, style='filled', fillcolor='lightblue', shape='ellipse')
        cluster.add_node(ip_node)
        graph.add_edge(pydot.Edge(node, ip_node))
        # SAN edges
        for san in cert_map.get(host,[]):
            if san != host:
                san_node = pydot.Node(f"üîñ {shorten_label(san)}\n[cert]", style='rounded')
                cluster.add_node(san_node)
                graph.add_edge(pydot.Edge(node,san_node,style='dashed'))
        # summary
        network_summary[asn_id]['cidrs'].add(info.get('cidr','Unknown'))
        network_summary[asn_id]['orgs'].add(info.get('org','Unknown Org'))
        network_summary[asn_id]['hosts'].append({'host':host,'ip':ip,'source':host_sources.get(host,'unknown')})
    # Footer node
    footer_node = pydot.Node('footer',label=FOOTER_TEXT, shape='plaintext', fontsize='14')
    graph.add_node(footer_node)
    footer_cluster = pydot.Cluster('footer_cluster', style='invis')
    footer_cluster.add_node(footer_node)
    graph.add_subgraph(footer_cluster)
    return graph, network_summary
# ----------------------------------------------------------------------------------------------------------


# Export graph and summaries
def export_graph(graph, latest_path):
    os.makedirs(latest_path, exist_ok=True)
    pdf_path = os.path.join(latest_path,'subdomains_clustered.pdf')
    svg_path = os.path.join(latest_path,'subdomains_clustered.svg')
    dot_path = os.path.join(latest_path,'subdomains_clustered.dot')
    try:
        graph.write_pdf(pdf_path)
        graph.write_svg(svg_path)
        graph.write_raw(dot_path)
        print(f"[+] Graph exported: PDF/SVG/DOT")
    except Exception as e:
        print(R + f"[!] Failed to export graph: {e}" + W)
# ----------------------------------------------------------------------------------------------------------


def export_network_summary(network_summary, latest_path):
    os.makedirs(latest_path, exist_ok=True)
    txt_file = os.path.join(latest_path,'network_info.txt')
    json_file = os.path.join(latest_path,'network_info.json')
    csv_file = os.path.join(latest_path,'network_info.csv')

    # TXT
    with open(txt_file,'w') as f:
        for asn,data in network_summary.items():
            f.write(f"ASN: {data['asn_display']}\nCountry: {data['country']}\nOrgs: {', '.join(data['orgs'])}\nCIDRs: {', '.join(data['cidrs'])}\n")
            for h in data['hosts']:
                f.write(f"  - {h['host']} -> {h['ip']} ({h['source']})\n")
            f.write("\n")
        f.write(FOOTER_TEXT+'\n')

    # JSON
    json_safe = {}
    for asn,data in network_summary.items():
        json_safe[asn] = {'asn_display':data['asn_display'],'country':data['country'],'orgs':list(data['orgs']),'cidrs':list(data['cidrs']),'hosts':data['hosts']}
    with open(json_file,'w') as f:
        json.dump({'network_summary':json_safe,'_footer':FOOTER_TEXT},f,indent=2)

    # CSV
    with open(csv_file,'w',newline='') as f:
        writer = csv.writer(f)
        writer.writerow(['asn','country','orgs','cidrs','host','ip','source'])
        for asn,data in network_summary.items():
            for h in data['hosts']:
                writer.writerow([data['asn_display'],data['country'],';'.join(data['orgs']),';'.join(data['cidrs']),h['host'],h['ip'],h['source']])
        writer.writerow([f"# {FOOTER_TEXT}"])

    print(f"[+] Network info exported: TXT/JSON/CSV with footer")
# ----------------------------------------------------------------------------------------------------------

# HTML interactive PyVis
def export_pyvis(network_summary, latest_path):
    if not PYVIS_AVAILABLE:
        print(Y+"PyVis/networkx not installed, skipping HTML export"+W)
        return
    try:
        G = nx.Graph()
        for asn,data in network_summary.items():
            for h in data['hosts']:
                G.add_node(h['host'], title=f"Host: {h['host']}<br>IP: {h['ip']}")
                G.add_node(h['ip'], title=f"IP: {h['ip']}<br>ASN: {data.get('asn_display','Unknown')}<br>Country: {data.get('country','??')}")
                G.add_edge(h['host'],h['ip'])
        net = Network(height='1000px', width='100%', notebook=False)
        net.from_nx(G)
        outpath = os.path.join(latest_path,'subdomains_map.html')
        net.write_html(outpath)
        # inject footer
        with open(outpath,'r',encoding='utf-8') as f:
            html=f.read()
        html=html.replace('</body>',f'<div style="position:fixed;bottom:8px;left:8px;font-size:12px;opacity:0.8;z-index:9999;">{FOOTER_TEXT}</div></body>')
        with open(outpath,'w',encoding='utf-8') as f:
            f.write(html)
        print(f"[+] Interactive map exported: {outpath}")
    except Exception as e:
        print(R+"Failed PyVis export: "+str(e)+W)

# ----------------------------------------------------------------------------------------------------------
# Main async workflow
async def main_async(sub_file, brut_file, latest_path):
    host_sources, hosts = merge_sources(sub_file, brut_file)
    print("")
    print(f"[+] Resolving {len(hosts)} hosts...")
    ip_map = await resolve_all_ips(hosts)
    if not ip_map:
        print("")
        print("[-] No hosts resolved")
        return
    await prefetch_network_info(set(ip_map.values()))
    cert_map = await fetch_certs_for_hosts(hosts)
    graph, network_summary = build_graph_with_clusters(ip_map, host_sources, cert_map)
    export_graph(graph, latest_path)
    export_network_summary(network_summary, latest_path)
    export_pyvis(network_summary, latest_path)
    # Save certs
    cert_file = os.path.join(latest_path,'cert_sans.json')
    with open(cert_file,'w') as f:
        json.dump(cert_map,f,indent=2)
    print(f"[+] Certificate SAN map saved: {cert_file}")

# ----------------------------------------------------------------------------------------------------------
# Latest folder
def get_latest_date_folder(base_path):
    try:
        folders = [f for f in os.listdir(base_path) if os.path.isdir(os.path.join(base_path,f))]
    except Exception:
        print(R+"Base folder not found: "+base_path+W); sys.exit(1)
    date_folders=[]
    for f in folders:
        try: date_folders.append((datetime.strptime(f,'%Y-%m-%d'),f))
        except Exception: pass
    if not date_folders: print(R+"No date folders found"+W); sys.exit(1)
    date_folders.sort()
    return os.path.join(base_path,date_folders[-1][1])

# ----------------------------------------------------------------------------------------------------------
# Main map function
def tuga_map(target):
    base_path = os.path.join('results', target)
    latest_path = get_latest_date_folder(base_path)
    print(Y+f"Using folder: {latest_path}"+W)

    # create map folder inside latest_path
    map_path = os.path.join(latest_path, 'map')
    os.makedirs(map_path, exist_ok=True)

    sub_file = os.path.join(latest_path,'osint_subdomains.txt')
    brut_file = os.path.join(latest_path,'tuga_bruteforce.txt')

    if not os.path.isfile(sub_file) and not os.path.isfile(brut_file):
        print(R+"No subdomains/bruteforce files found"+W); sys.exit(1)
    #asyncio.run(main_async(sub_file,brut_file,latest_path))
    asyncio.run(main_async(sub_file, brut_file, map_path))
